# 优志愿-webpack逆向

目标网址：https://www.youzy.cn/tzy/search/colleges/collegeList







## 需要注意的点





1. 要注意那个如果传入的参数是`json`的话，要导入`'https://uwf7de983aad7a717eb.youzy.cn/youzy.dms.basiclib.api.college.query'`保证格式统一。

2. 搜索参数的时候，一定要点击，右上角三个小点里面的搜索。

3. 看函数，就看结果（判断这个函数是不是问我们的目标函数），参数（传入的参数是不是和我们所需要的变量有关，比如我们要查询不同地区的经济指标，这个地区可能作为参数传入），函数体（运行逻辑）。

4. `a()(o)`我们查看方法要点击`a()`不然a是查不到的，我们优先是整体大于局部。

5. 下面是一个典型的md5加密：

   ~~~js
   a = function(e, r) {
                   e.constructor == String ? e = r && "binary" === r.encoding ? i.stringToBytes(e) : n.stringToBytes(e) : o(e) ? e = Array.prototype.slice.call(e, 0) : Array.isArray(e) || e.constructor === Uint8Array || (e = e.toString());
                   for (var s = t.bytesToWords(e), u = 8 * e.length, c = 1732584193, f = -271733879, d = -1732584194, l = 271733878, h = 0; h < s.length; h++)
                       s[h] = 16711935 & (s[h] << 8 | s[h] >>> 24) | 4278255360 & (s[h] << 24 | s[h] >>> 8);
                   s[u >>> 5] |= 128 << u % 32,
                   s[14 + (u + 64 >>> 9 << 4)] = u;
                   var p = a._ff
                     , b = a._gg
                     , y = a._hh
                     , m = a._ii;
                   for (h = 0; h < s.length; h += 16) {
                       var g = c
                         , v = f
                         , _ = d
                         , w = l;
                       c = p(c, f, d, l, s[h + 0], 7, -680876936),
                       l = p(l, c, f, d, s[h + 1], 12, -389564586),
                       d = p(d, l, c, f, s[h + 2], 17, 606105819),
                       f = p(f, d, l, c, s[h + 3], 22, -1044525330),
                       c = p(c, f, d, l, s[h + 4], 7, -176418897),
                       l = p(l, c, f, d, s[h + 5], 12, 1200080426),
                       d = p(d, l, c, f, s[h + 6], 17, -1473231341),
                       f = p(f, d, l, c, s[h + 7], 22, -45705983),
                       c = p(c, f, d, l, s[h + 8], 7, 1770035416),
                       l = p(l, c, f, d, s[h + 9], 12, -1958414417),
                       d = p(d, l, c, f, s[h + 10], 17, -42063),
                       f = p(f, d, l, c, s[h + 11], 22, -1990404162),
                       c = p(c, f, d, l, s[h + 12], 7, 1804603682),
                       l = p(l, c, f, d, s[h + 13], 12, -40341101),
                       d = p(d, l, c, f, s[h + 14], 17, -1502002290),
                       c = b(c, f = p(f, d, l, c, s[h + 15], 22, 1236535329), d, l, s[h + 1], 5, -165796510),
                       l = b(l, c, f, d, s[h + 6], 9, -1069501632),
                       d = b(d, l, c, f, s[h + 11], 14, 643717713),
                       f = b(f, d, l, c, s[h + 0], 20, -373897302),
                       c = b(c, f, d, l, s[h + 5], 5, -701558691),
                       l = b(l, c, f, d, s[h + 10], 9, 38016083),
                       d = b(d, l, c, f, s[h + 15], 14, -660478335),
                       f = b(f, d, l, c, s[h + 4], 20, -405537848),
   ~~~

6. 我们上下看的时候看到了这个就是`webpack`（可以全局搜索`webpack`来验证自己的猜想）：

   ~~~js
   6821: function(e, t, r) {
           !function() {
               var t = r("00d8")
                 , n = r("9a63").utf8
                 , o = r("8349")
                 , i = r("9a63").bin
                 , a = function(e, r) {
   ~~~

7. 发现缺少环境`windows`直接就补`window= global;`就行

8. 导出加载器：在加载器r函数的后面，写上一段代码`window._r = r;`

9. 传参的时候一定要注意参数的类型，比如`json`要导入`'https://uwf7de983aad7a717eb.youzy.cn/youzy.dms.basiclib.api.college.query'`保证格式统一。
10. 不会的一定要去问一下AI，我问一下AI已下载就解决了


























## 执行流程



1. 先直接搜索“北京大学”找到对应的包`youzy.dms.basiclib.api.college.query`

2. 发现有一个参数里面有一个参数是加密的`u-sign`。（如果不知道哪一个参数是加密的，那就用控制变量法，先去除掉一个参数，看能不能请求成功，如果能，这个就是无关紧要的，反之则是必然的）

3. 直接搜索`u-sign`，发现有11个，我们直接打断点，然后刷新一下看一下断点断在哪就行

4. 然后把断点搜删除干净，只留意下断点的那一个，留这个` "u-sign": c(e.url, e.data),`

5. 我们到控制台里面运行一下这个函数就是我们要的`u-sign`

6. 接下来，看函数是哪一个，直接光标悬停在上面，点击下面的超链接就行。参数也要看一下。

7. 参数的话直接用`copy`复制到代码里面

8. 这个时候参数和结果都确定了，就照函数体，看里面的执行逻辑就行了

9. 然后点进函数看一下，里面的逻辑是怎么的（可以直接复制到`pycharm`，看一下可不可以运行，可以的话就说明有用了）

10. 运行一下，发现是一个缺少a方法，点进去看看，卡在这里：`a()(o)`我们查看方法要点击`a()`不然a是查不到的，我们优先是整体大于局部。

11. 在`a()`方法中，这里又是关键函数。我们再点击这里` var n = t.wordsToBytes(a(e, r));`

12. 我们查看这个函数的时候，看了一下`t.wordsToBytes`就是一个字节流，所以我们核心看这个a。

13. 我们看一下`a`就是典型的做了一个md5加密：
    ~~~js
    a = function(e, r) {
                    e.constructor == String ? e = r && "binary" === r.encoding ? i.stringToBytes(e) : n.stringToBytes(e) : o(e) ? e = Array.prototype.slice.call(e, 0) : Array.isArray(e) || e.constructor === Uint8Array || (e = e.toString());
                    for (var s = t.bytesToWords(e), u = 8 * e.length, c = 1732584193, f = -271733879, d = -1732584194, l = 271733878, h = 0; h < s.length; h++)
                        s[h] = 16711935 & (s[h] << 8 | s[h] >>> 24) | 4278255360 & (s[h] << 24 | s[h] >>> 8);
                    s[u >>> 5] |= 128 << u % 32,
                    s[14 + (u + 64 >>> 9 << 4)] = u;
                    var p = a._ff
                      , b = a._gg
                      , y = a._hh
                      , m = a._ii;
                    for (h = 0; h < s.length; h += 16) {
                        var g = c
                          , v = f
                          , _ = d
                          , w = l;
                        c = p(c, f, d, l, s[h + 0], 7, -680876936),
                        l = p(l, c, f, d, s[h + 1], 12, -389564586),
                        d = p(d, l, c, f, s[h + 2], 17, 606105819),
                        f = p(f, d, l, c, s[h + 3], 22, -1044525330),
                        c = p(c, f, d, l, s[h + 4], 7, -176418897),
                        l = p(l, c, f, d, s[h + 5], 12, 1200080426),
                        d = p(d, l, c, f, s[h + 6], 17, -1473231341),
                        f = p(f, d, l, c, s[h + 7], 22, -45705983),
                        c = p(c, f, d, l, s[h + 8], 7, 1770035416),
                        l = p(l, c, f, d, s[h + 9], 12, -1958414417),
                        d = p(d, l, c, f, s[h + 10], 17, -42063),
                        f = p(f, d, l, c, s[h + 11], 22, -1990404162),
                        c = p(c, f, d, l, s[h + 12], 7, 1804603682),
                        l = p(l, c, f, d, s[h + 13], 12, -40341101),
                        d = p(d, l, c, f, s[h + 14], 17, -1502002290),
                        c = b(c, f = p(f, d, l, c, s[h + 15], 22, 1236535329), d, l, s[h + 1], 5, -165796510),
                        l = b(l, c, f, d, s[h + 6], 9, -1069501632),
                        d = b(d, l, c, f, s[h + 11], 14, 643717713),
                        f = b(f, d, l, c, s[h + 0], 20, -373897302),
                        c = b(c, f, d, l, s[h + 5], 5, -701558691),
                        l = b(l, c, f, d, s[h + 10], 9, 38016083),
                        d = b(d, l, c, f, s[h + 15], 14, -660478335),
                        f = b(f, d, l, c, s[h + 4], 20, -405537848),
                         
    ~~~

14. 我们上下看的时候看到了这个（可以全局搜索`webpack`来验证自己的猜想）：
    ~~~js
    6821: function(e, t, r) {
            !function() {
                var t = r("00d8")
                  , n = r("9a63").utf8
                  , o = r("8349")
                  , i = r("9a63").bin
                  , a = function(e, r) {
    ~~~

15. 这个就是一个典型的`webpack`

16. 碰到`webpack`先找选择器，如何找选择器呢？，下面讲讲怎么找选择器

17. 找了几个，因为都是` i = r("6821")`,其他的模块也是`s = r("2f8d")`因为调用模块必须要用到加载器。

18. 点击进入`r`函数，也就是加载器。

19. 然后直接把整个加载器函数放到pycharm里面。

20. 运行一下，发现缺少环境`windows`直接就补`window= global;`就行

21. 然后我们把加载器导出来，怎么导出来呢？

22. 在加载器r函数的后面，写上一段代码`window._r = r;`

23. 记得先把下面的注释掉，我们现在做的只是提取这个加载器

24. 我们测试一下`window._r("5880")`，报错了` Vuex is not defined`

25. 直接把这一行换成`console.log`就行

26. 运行一下，成功了，现在就去找我对应的模块了，因为我们现在是测试了5880，我们的目标模块是6821

27. 我们直接把6821模块复制到加载器里面。然后运行一下，测试一下。

28. 报错了`Cannot read properties of undefined (reading 'call')`，这个其实就是缺少了一些模块，因为这个调用6821模块的时候也会调用其他模块的。

29. 我们可以在对应函数上面打印一下n，看一下是缺少哪个模块，也可以直接看模块里面，是缺少哪一些模块。
    ~~~js
        function r(n) {
            
            
            
            
            
            console.log(n)
            
            
            
            
            
            if (t[n])
                return t[n].exports;
            var c = t[n] = {
                i: n,
                l: !1,
                exports: {}
            };
            return e[n].call(c.exports, c, c.exports, r),
    ~~~

30. 在6821模块前面有这些模块需要补，有时候不起来是很多的，可能就需要自动补webpack模块了，或者全扣也可以，这里比较简单，扣几个就行了。
    ~~~js
                var t = r("00d8")
                  , n = r("9a63").utf8
                  , o = r("8349")
                  , i = r("9a63").bin
    ~~~

31. 把这些模块都补好之后，再运行

32. 再把之前缺少的方法换成`_a`，然后用之前调用的模块赋值给`_a`
    ~~~js
    var _a = window._r("6821")
    ~~~

33. 运行一下就能跑出来结果

34. 为什么这个`window._r("6821")`就是之前的`a()`方法，因为`a()`方法多转几层，就转到了模块6821里面了，并且他刚好是在`e.exports =`这个函数里面，这个函数是窗口函数，也就是模块6821模块对外的一个方法，简单来说，你直接拿到6821模块没什么用，要通过加载器加载一下这个模块才能用，给谁用，就是刚刚那个模块用。

35. 































