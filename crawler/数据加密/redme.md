









# 加密货币爬取







目标网址：https://www.coinglass.com/zh













## 需要注意的点



- hook一定是发生在数据被解密前， 所以说一定要在他解密之前注入，
  - 这个网站是一个实时发数据的网站，所以直接复制它就会打上断点，但是要是一个只有一次的，
  - 那可以翻页，或者下一页，
  - 再不行，就在这个数据包的堆栈的最下方打上断点，这个时候注入，他回家没有发生，然后松开断电就行了
  
- 过这里要注意的时候，parse用了俩次，一次是用在把加密数据转化为对象进行操作，把里面的数据解密的，第二次是把解密之后的数据再转化为对象渲染到网页上，我们要的是第二次，所以我们要跳过一次。

- 当发现某一个断点，有很多次断点，说明有干扰，这个时候我们可以直接用条件断点。

- 数据加密常见的思路：其实思路是比较多的，比如打`XHR断点`或者是使用`decrypt(`定位解密函数，亦或者使用我们常用的`拦截器`。

- 通过输入和输出，发现，这个函数就是我们要的入口函数。（记住一定要看输入的内容，因为会有很多的干扰，有一些参数不是的，所以结果也不是我们想要的，要看参数是加密的参数，然后结果是数据，那这个就是入口函数了）

- 入口函数是，te，我直接在te后面插入，这肯定是不对的，因为你要看整体，整体是在声明多个变量，你中间插入一个，就是错误的。应该是在ee函数结束位置插入：`global.huangwei=te`

  ![image-20251130215853064](C:\Users\35796\AppData\Roaming\Typora\typora-user-images\image-20251130215853064.png)
  
  
  
- 
  
  
  
  
  





## 基本流程

2. 抓包分析了一下主要是数据加密，参数没有加密。

3. 看了一下请求头，发现是请求里面的接受数据的格式是json，那么基本上可以断定，他这里面一定用了json.paser这个方法来渲染到网页的。
   ![image-20251130140957513](C:\Users\35796\AppData\Roaming\Typora\typora-user-images\image-20251130140957513.png)

4. 网络传输的流程是这样的。
   ![image-20251130141702943](C:\Users\35796\AppData\Roaming\Typora\typora-user-images\image-20251130141702943.png)

5. 写上hook脚本：
   ~~~js
   var my_paser = JSON.parse;
   JSON.parse = function (params){
       debugger
       console.log("josn_parse params:",params);
       return my_parse(params);
   };
   ~~~

6. 在这里直接复制到浏览器控制台就行（因为他会不断的获取数据，这个网站是一个实时获取数据的网站）。有一些只有一次，那就要打断点在他没发生发之前，然后这个时候注入就行了。

7. 逆向，直接对战分析往前找就行了，不过这里要注意的时候，parse用了俩次，一次是用在把加密数据转化为对象进行操作，把里面的数据解密的，第二次是把解密之后的数据再转化为对象渲染到网页上，我们要的是第二次，所以我们要跳过一次。





这里有三种方法，上面那种是打断点的方法，还有俩种比较简单的方法。

> 其实思路是比较多的，比如打`XHR断点`或者是使用`decrypt(`定位解密函数，亦或者使用我们常用的`拦截器`



下面是搜索`decrypt(`的思路，一般数据加密就用拦截器：





1. 搜索拦截器：`decrypt(`，全部打上断点。

2. 然后找到了可疑的代码。

3. 通过输入和输出，发现，这个函数就是我们要的入口函数。（记住一定要看输入的内容，因为会有很多的干扰，有一些参数不是的，所以结果也不是我们想要的，要看参数是加密的参数，然后结果是数据，那这个就是入口函数了）。

4. 入口函数是：
   ~~~js
   te = function(t, e) {
               var n = Xt
                 , r = {
                   SQPqK: function(t, e) {
                       return t(e)
                   },
                   wCBII: function(t, e) {
                       return t == e
                   },
                   sRlKl: function(t, e) {
                       return t == e
                   },
                   KthDg: function(t, e) {
                       return t - e
                   }
               }
                 , i = Yt()[n(154, "Gmlx")].decrypt(t, Yt()[n(319, "SuJ]")].Utf8.parse(e), {
                   mode: Yt()[n(204, "EBwR")].ECB,
                   padding: Yt()[n(274, "bctm")][n(146, "(@r[")]
               })[n(259, "Q9bH")](Yt().enc.Hex)
                 , o = r[n(238, "H21h")](Qt, i);
               return r.wCBII(o.charAt(0), '"') && (o = o[n(212, "Le1o")](1, o.length)),
               r[n(311, "7iaM")](o[n(288, "SuJ]")](r.KthDg(o[n(121, "iVPA")], 1)), '"') && (o = o.substring(0, o[n(313, "NPK3")] - 1)),
               o
           }
   ~~~

5. 入口函数是，`te`，我直接在`te`后面插入，这肯定是不对的，因为你要看整体，整体是在声明多个变量，你中间插入一个，就是错误的。应该是在`ee`函数结束位置插入：`global.huangwei=te`

6. 

